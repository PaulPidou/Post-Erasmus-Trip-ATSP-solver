<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: TSP.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: TSP.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Problem instance (API) module:TSP.&lt;br/>
 * useage:
 * &lt;pre class="prettyprint">
 * var tsp_instance = new TSP(waypoints,distanceTable);
 * tsp_instance.solve(algo,mode,threadCount,function () {
 *     // Success
 * }, function (err) {
 *    // Error
 * }, function (progress) {
 *     // Progress
 * }, function(){
 *
 * });
 * &lt;/pre>
 * @module TSP_API
 */
(function(globals){
  "use strict";	
	
	/**
	 * Represents a Traveling Salesman Problem
	 * @constructor
	 * @param {array} distanceTable - Distance table
	 * @param {array} waypoints - Waypoints array (currently not needed)
	 */
	globals.TSP = function(distanceTable,waypoints){
		
		var thisTSP = this;
		
		/** Stop a calculation which is in progress */
		this.stop = function(){
			this.stopped = true;
			
			if( thisTSP.mode === 'singlethread' ){
				this.worker.postMessage({ cmd: 'stop' } );
			} else if( thisTSP.mode === 'server' || thisTSP.mode === 'server_multithread' ) {
			
			} else {
				thisTSP.solver.stop();
			}
			
		};
		
		this.algoNames = {
			'BruteForce': 'brute force',
			'BnB': 'branch and bound',
			'Antcolonyk2_k3': 'Ant colony and k3',
			//'Dynamic': 'dynamic',
			'Antcolonyk2': 'ant colony and k2',
			'Nearestneighbour': 'nearest neighbour',
			'Dynamic' : 'dynamic (held karp)'
		};
		
		this.mode = null;
		this.algo = null;
		this.threadCount = null;
		this.running = false;
		this.stopped = false;
		
		/* detect the performance of the current client, currentyl not used */
		this.detectPerformance = function(){
		
			window.performance = window.performance || {};
			performance.now = (function() {
			  return performance.now       ||
			         performance.mozNow    ||
			         performance.msNow     ||
			         performance.oNow      ||
			         performance.webkitNow ||
			         function() { return new Date().getTime(); };
			})();
		
		
			var time = window.performance.now(); //time in milliseconds
			for( var i = 0; i&lt;100000000 ; i++ ){
				//iterate
			}
			var diff = window.performance.now()-time;
			//console.error(diff);
		};
		
		/* init the TSP */
		this.init = function(distanceTable,waypoints){
			thisTSP.distanceTable = distanceTable;
			thisTSP.waypoints = waypoints;
			thisTSP._problemSize = false;
		};
		this.init(distanceTable,waypoints);
		
		/* returns the problem size of the tsp, based on the distance table */
		this.getProblemSize = function(){
			if( thisTSP._problemSize === false ){
				thisTSP._problemSize = thisTSP.distanceTable.length;
			}
			return this._problemSize;
			
		};
		
		/**
		 * Solve the TSP
		 * @param {mixed} algo - true (boolean) to autodetect best fitting algorithm for the tsp.
		 * BruteForce / BnB / Dynamic / Antcolonyk2_k3 / Nearestneighbour to solve with a specific algorithm.
		 * @param {mixed} mode - true (boolean) to autodetect best fitting execution mode.
		 * normal / singlethread / webworker / server / server_multithread / client_distributed
		 * @param {mixed} threadCount - If multithread execution mode selected, specify maximum of threads to use
		 * @param {function} successFnct - function which is called after successfull execution of the method solve
		 * @param {function} errorFnct - function which is called after an error occured and the execution of the solve method is aborted
		 * @param {function} progressFnct - function which is called when a new solution is found by the algorithm
		 */
		this.solve = function(algo,mode,threadCount,successFnct,errorFnct,progressFnct){			
		
			thisTSP.mode = mode;
			thisTSP.algo = algo;
			thisTSP.threadCount = threadCount;
			var _this = this;
			//var cores = window.navigator.hardwareConcurrency;
			
			//autodetect:
			if( !thisTSP.mode || thisTSP.mode === true ){
				var problemsize = thisTSP.getProblemSize();
				if( problemsize &lt; 4 ){
					thisTSP.algo = 'BruteForce';
					thisTSP.mode = 'normal';
				} else if( problemsize &lt; 10 ){
					thisTSP.algo = 'BruteForce';
					thisTSP.mode = 'singlethread';
				} else if( problemsize &lt; 11 ){
					thisTSP.algo = 'BnB';
					thisTSP.mode = 'webworker';
					thisTSP.threadCount = 2;
				} else if( problemsize &lt; 20 ){
					thisTSP.algo = 'Dynamic';
					thisTSP.mode = 'singlethread';
				} else if( problemsize &lt; 30 ){
					thisTSP.algo = 'Antcolonyk2_k3';
					thisTSP.mode = 'singlethread';
				} else if( problemsize &lt; 100 ){
					thisTSP.algo = 'Antcolonyk2';
					thisTSP.mode = 'singlethread';
				} else {
					thisTSP.algo = 'Nearestneighbour';
					thisTSP.mode = 'singlethread';
				}
			}
			
			/** returns the algorithm name by its identifier 
				* @param {string} identifier of the algorithm
				* @private
				* @static
			*/
			var getAlgoName = function(algo){
				var n = thisTSP.algoNames[algo];
				if( typeof n !== 'undefined ' ){
					return n;
				} else {
					return algo;
				}
			};
		
		
			thisTSP.stopped = false;
			
			/** message receiver
				* @param {object} identifier of the algorithm
				* @private
			*/
			this.postMessage = function(d){
				
				if( !d.type ) d.type = 'status';
				if ( d.type === 'status' ) {
					
					progressFnct({bestTour: d.bestTour, bestTourWeight: d.bestTourWeight});
					
				} else if( d.type === 'result' ) {
					
					successFnct({
						bestTour: d.bestTour, 
						bestTourWeight: d.bestTourWeight, 
						startTour: d.startTour, 
						startTourWeight: d.startTourWeight, 
						optimization: Math.round((1-(d.bestTourWeight/d.startTourWeight))*100*100)/100, /* Math.round( xx*100) / 100 => rounding 2 decimals*/
						algo: thisTSP.algo,
						algoname: getAlgoName(thisTSP.algo),
						mode: thisTSP.mode,
						threads: thisTSP.threadCount
					});
				} else if(d.type == "console.log") {
					//console.log.apply(console, d.data);
				}
			};
		
		
			if( mode === 'singlethread' ){
			
				thisTSP.worker = new Worker(TSP_SOLVER_DOMAIN+ "/TSP_Solver.js");
				/* event listener for messaging with main thread: */
				thisTSP.worker.onmessage = function(d){
					_this.postMessage(clone(d.data));
				};
				thisTSP.worker.postMessage({ 
					cmd: 'tsp', 
					waypoints: thisTSP.waypoints, 
					distanceTable: thisTSP.distanceTable , 
					algo: thisTSP.algo, 
					mode: thisTSP.mode, 
					modeThreadC: 0} 
				);
			
			} else {
				
				//adjust thread count if too many sent:
				if(mode === 'webworker' ){
					/*if( thisTSP.threadCount == 1 ){
						thisTSP.threadCount = (thisTSP.distanceTable.length-1);
						console.error( 'thread count adjusted to',thisTSP.threadCount);
					}
					*/
					if(thisTSP.threadCount){
						if( thisTSP.threadCount > (thisTSP.distanceTable.length-1) ){
							thisTSP.threadCount = (thisTSP.distanceTable.length-1);
							console.error( 'thread count adjusted to',thisTSP.threadCount);
						}
					}
				}
				
				if( mode === 'server' || mode === 'server_multithread' ){
					//ajax request to server:
					$.ajax({
						dataType: "jsonp",
						type: "post",
					  	url: "http://yourserver.com:8001",
					  	data: { 
					  		cmd: 'tsp', 
					  		waypoints: JSON.stringify(thisTSP.waypoints), 
					  		distanceTable: JSON.stringify(thisTSP.distanceTable) , 
					  		algo: thisTSP.algo, 
					  		mode: thisTSP.mode, 
					  		modeThreadC: thisTSP.threadCount
					  	},
					  	success: function(d){
					  		_this.postMessage(d);
					  	},
					  	error: function(e){
					  		alert('hui');
					  		e.error = true;
					  		_this.postMessage(e);
					  	}
					});
				} else {
					thisTSP.solver = globals.solve_tsp_helper_function(this,thisTSP.waypoints,thisTSP.distanceTable,thisTSP.algo,thisTSP.mode,thisTSP.threadCount);
				}	
			}
		
			
			return this;
		};
	};
	
	
}(this));</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Application.html">Application</a></li><li><a href="module-Benchmark.html">Benchmark</a></li><li><a href="module-RandomWaypoints.html">RandomWaypoints</a></li><li><a href="module-TSP_API.html">TSP_API</a></li><li><a href="module-TSP_Solver.html">TSP_Solver</a></li><li><a href="module-TSP_Solver_Worker.html">TSP_Solver_Worker</a></li></ul><h3>Classes</h3><ul><li><a href="module-TSP_API-globals.TSP.html">TSP</a></li><li><a href="module-TSP_Solver_Worker-globals.tsp.html">tsp</a></li><li><a href="module-TSP_Solver_Worker-globals.TSP_Node_Calc.html">TSP_Node_Calc</a></li><li><a href="module-TSP_Solver-globals.TSP_Solver.html">TSP_Solver</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta3</a> on Mon Apr 13 2015 21:30:39 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
